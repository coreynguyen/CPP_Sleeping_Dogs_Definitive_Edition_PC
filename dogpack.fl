# data file for the Fltk User Interface Designer (fluid)
version 1.0305
header_name {./include/interface.h}
code_name {./src/interface.cxx}
comment {/*
 ________  ___  ___  ________  _________        ________  ________  _________        ___   ___
|\\   ____\\|\\  \\|\\  \\|\\   __  \\|\\___   ___\\     |\\   ____\\|\\   __  \\|\\___   ___\\     |\\  \\ |\\  \\
\\ \\  \\___|\\ \\  \\\\\\  \\ \\  \\|\\  \\|___ \\  \\_|     \\ \\  \\___|\\ \\  \\|\\  \\|___ \\  \\_|     \\ \\  \\\\_\\  \\  _______
 \\ \\  \\    \\ \\   __  \\ \\   __  \\   \\ \\  \\       \\ \\  \\  __\\ \\   ____\\   \\ \\  \\       \\ \\______  \\|\\  ___ \\
  \\ \\  \\____\\ \\  \\ \\  \\ \\  \\ \\  \\   \\ \\  \\       \\ \\  \\|\\  \\ \\  \\___|    \\ \\  \\       \\|_____|\\  \\ \\ \\__\\ \\
   \\ \\_______\\ \\__\\ \\__\\ \\__\\ \\__\\   \\ \\__\\       \\ \\_______\\ \\__\\        \\ \\__\\             \\ \\__\\ \\______\\
    \\|_______|\\|__|\\|__|\\|__|\\|__|    \\|__|        \\|_______|\\|__|         \\|__|              \\|__|\\|______|

*/} {in_source in_header
}

comment {change '\#include "./include/interface.h"' to \#include "interface.h"} {in_source not_in_header
}

decl {\#include "version.h"} {public global
}

decl {\#include "resource.h"} {public global
}

decl {\#include "filesystem.h"} {public global
}

decl {\#include "QuickCompression.h"} {public global
}

decl {\#include "guiicon.h"} {private local
}

decl {\#include <sstream>} {public global
}

decl {\#include <iomanip>} {public global
}

decl {\#include <sstream>} {public global
}

decl {\#include <string>} {public global
}

decl {\#include <vector>} {public global
}

decl {\#include <numeric>} {public global
}

decl {\#include <chrono>} {public global
}

decl {\#include <ctime>} {public global
}

decl {\#include <cmath>} {public global
}

decl {\#include <FL/x.H>} {public global
}

decl {\#include <FL/fl_ask.H>} {public global
}

decl {\#include <FL/fl_draw.H>} {public global
}

decl {\#include <FL/Fl_File_Chooser.H>} {public global
}

decl {\#include <FL/Fl_Multi_Label.H>} {public global
}

decl {\#include <FL/Fl_Table_Row.H>} {public global
}

decl {\#include <FL/Fl_Pixmap.H>} {public global
}

decl {\#include <FL/Fl_Image.H>} {public global
}

decl {\#include "interface_logo.h"} {public global
}

decl {\#include "Filenames.h"} {public global
}

decl {\#include "BigInventoryFile.h"} {public global
}

decl {std::vector<BigInventoryEntry_t> entries;} {private global
}

decl {std::string app_version;} {public local
}

decl {std::string app_filename;} {public local
}

Function {to_hex_string(uint32_t num)} {private return_type {std::string}
} {
  code {std::stringstream ss;
    ss << std::uppercase << std::hex << std::setw(8) << std::setfill('0') << num;
    return ss.str();} {}
}

Function {to_uppercase(const std::string& str)} {private return_type {std::string}
} {
  code {std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(), [](unsigned char c){ return std::toupper(c); });
    return result;} {}
}

Function {updateTable()} {private return_type void
} {
  code {lbox_files->rows(entries.size());
    lbox_files->cols(5);
    lbox_files->redraw();} {}
}

decl {bool USE_DARK_MODE;} {public local
}

Function {updateLabels()} {return_type void
} {
  code {// Ensure m_ArchiveName is null-terminated and properly handled
const char* archiveNameCStr = globalBigInventory.m_ArchiveName;
// Find the position of the first null character or the end of the buffer
size_t length = std::find(archiveNameCStr, archiveNameCStr + sizeof(globalBigInventory.m_ArchiveName), '\\0') - archiveNameCStr;
// Create a string up to that point
std::string archiveName(archiveNameCStr, length);
app_filename = archiveName;

// Clear the existing label and set the new archive name
stb_llabel->copy_label("");
stb_llabel->copy_label(app_filename.c_str());

// Extract version information
std::string versionInfo = appver;

size_t startPos = versionInfo.find('v');
if (startPos != std::string::npos) {
    size_t endPos = versionInfo.find(' ', startPos);
    if (endPos != std::string::npos) {
        app_version = versionInfo.substr(startPos, endPos - startPos);
    } else {
        app_version = versionInfo.substr(startPos);
    }
}

// Clear the existing label and set the new version information
stb_rlabel->copy_label("");
stb_rlabel->label(app_version.c_str());} {}
}

Function {exportSelectedFiles()} {private return_type void
} {
  code {HANDLE hBigFile = CreateFile(globalBigPath.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if (hBigFile == INVALID_HANDLE_VALUE) {
    std::cerr << "Could not open original big file!" << std::endl;
    return;
}

int selectedRowCount = 0;
std::vector<int> selectedRows;

// Count selected rows and store their indices
for (int row = 0; row < lbox_files->rows(); ++row) {
    if (lbox_files->row_selected(row)) {
        ++selectedRowCount;
        selectedRows.push_back(row);
    }
}

if (selectedRowCount == 1) {
    // Export a single file
    int row = selectedRows[0];
    int entryIndex = lbox_files->row_to_entry_map[row]; // Use updated row-to-entry map
    BigInventoryEntry_t& entry = globalBigInventory.entry[entryIndex];
    std::string fileName = getFilePathFromHash(entry.m_NameUID);
    if (fileName.empty()) {
        // Handle empty filename case
    }

    std::string exportPath = os::getSaveFileName("All Files (*.*)\\0*.*\\0", GetActiveWindow(), fileName.c_str());
    if (exportPath.empty()) {
        CloseHandle(hBigFile);
        return;
    }

    exportFile(hBigFile, exportPath, entry, false);
}
else if (selectedRowCount > 1) {
    // Export multiple files to a directory
    std::string exportDir = os::getSavePath("Select Export Directory", "Select Folder to Export Files", BIF_NEWDIALOGSTYLE | BIF_EDITBOX, GetActiveWindow());
    if (exportDir.empty()) {
        CloseHandle(hBigFile);
        return;
    }

    for (int row : selectedRows) {
        int entryIndex = lbox_files->row_to_entry_map[row]; // Use updated row-to-entry map
        BigInventoryEntry_t& entry = globalBigInventory.entry[entryIndex];
        std::string fileName = getFilePathFromHash(entry.m_NameUID);
        if (!fileName.empty()) {
            std::string exportPath = exportDir + "\\\\" + fileName;
            exportFile(hBigFile, exportPath, entry, true);
        }
    }
}

CloseHandle(hBigFile);


// Display success message box
fl_message("Files have been successfully exported.");} {}
}

Function {importFileToSelectedRow()} {private return_type void
} {
  code {if (globalBixPath.empty() || globalBigPath.empty()) {
    fl_alert("No BIX file loaded!");
    return;
}

// Using the native Windows file open dialog for single file selection
const std::string importFilePath = os::getOpenFileName("All Files (*.*)\\0*.*\\0", GetActiveWindow());
if (importFilePath.empty()) {
    return;
}

// Debug print
std::cout << "Selected File: " << importFilePath << std::endl;

// Get all selected rows
std::vector < int > selectedRows;
for (int row = 0; row < lbox_files -> rows(); ++row) {
    if (lbox_files -> row_selected(row)) {
        selectedRows.push_back(row);
    }
}

if (selectedRows.empty()) {
    fl_alert("No rows selected!");
    return;
}

// Replace the selected file for each selected row
for (int selectedRow: selectedRows) {
    std::cout << "Selected Row: " << selectedRow << std::endl;

    if (selectedRow < lbox_files -> row_to_entry_map.size()) {
        int entryIndex = lbox_files -> row_to_entry_map[selectedRow];
        if (entryIndex < globalBigInventory.entry.size()) {
            std::cout << "Overwriting entry: " << getFilePathFromHash(globalBigInventory.entry[entryIndex].m_NameUID) << std::endl;

            // Mark the entry as edited and update the import map
            importFilesMap[entryIndex] = importFilePath;
            lbox_files -> data[selectedRow][4] = "EDITED"; // Update the status to "EDITED"
        } else {
            std::cout << "Selected row is out of range of entries." << std::endl;
        }
    } else {
        std::cout << "Selected row is out of range of map." << std::endl;
    }
}

lbox_files -> redraw();} {}
}

Function {exportAllFiles()} {private return_type void
} {
  code {// Check if there are any entries to export
if (globalBigInventory.entry.empty()) {
    fl_alert("There are no files to export.");
    return;
}

// Prompt the user to select a directory to save the exported files
std::string exportDir = os::getSavePath("", "Select Export Directory", BIF_NEWDIALOGSTYLE | BIF_EDITBOX, GetActiveWindow());
if (exportDir.empty()) {
    return;
}


// Open original .big file
HANDLE hBigFile = CreateFile(globalBigPath.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if (hBigFile == INVALID_HANDLE_VALUE) {
    std::cerr << "Could not open original big file!" << std::endl;
    return;
}

// Iterate through all entries in the archive
for (size_t i = 0; i < globalBigInventory.entry.size(); ++i) {
    BigInventoryEntry_t& entry = globalBigInventory.entry[i];
    exportFile(hBigFile, exportDir, entry, true);
}

// Close the original .big file
CloseHandle(hBigFile);

// Display success message box
fl_message("Files have been successfully exported.");} {}
}

Function {importAllFiles()} {open private return_type void
} {
  code {if (globalBixPath.empty() || globalBigPath.empty()) {
    fl_alert("No BIX file loaded!");
    return;
}

std::string folderPath = os::getSavePath("Select Folder", "Select Folder to Import Files", BIF_NEWDIALOGSTYLE | BIF_EDITBOX, GetActiveWindow());
if (folderPath.empty()) {
    return;
}

if (folderPath.back() != '\\\\' && folderPath.back() != '/') {
    folderPath += "\\\\";
}

//std::cout << "Selected Folder: " << folderPath << std::endl;

std::vector<std::string> allFiles = os::getFilesRecursive(folderPath);
if (allFiles.empty()) {
    fl_alert("No files found in the selected folder!");
    return;
}

std::cout << "Total Files Found: " << allFiles.size() << std::endl;

for (const auto& fullFilePath : allFiles) {
    std::string relativePath = fullFilePath.substr(folderPath.length());
    if (!relativePath.empty() && (relativePath[0] == '\\\\' || relativePath[0] == '/')) {
        relativePath = relativePath.substr(1);
    }

    toupper(relativePath);

    //std::cout << "Relative Path: " << relativePath << std::endl;

    uint32_t hash = StringHashUpper32(relativePath.c_str());
    //std::cout << "Calculated Hash: " << hash << std::endl;

    bool found = false;
    for (size_t i = 0; i < globalBigInventory.entry.size(); ++i) {
        if (globalBigInventory.entry[i].m_NameUID == hash) {
            //std::cout << "Matching File by calculated hash: " << relativePath << " with Hash: " << hash << std::endl;

            importFilesMap[i] = fullFilePath;
            lbox_files->data[lbox_files->row_to_entry_map[i]][4] = "EDITED";
            found = true;
            break;
        }
    }

    if (!found) {
        std::string baseName = relativePath.substr(relativePath.find_last_of("\\\\/") + 1);
        size_t lastDot = baseName.find_last_of('.');
        if (lastDot != std::string::npos) {
            baseName = baseName.substr(0, lastDot);
        }

        if (baseName.length() <= 8 && std::all_of(baseName.begin(), baseName.end(), isHexChar)) {
            std::stringstream ss;
            ss << std::hex << baseName;
            ss >> hash;

            //std::cout << "Extracted Hash from filename: " << hash << std::endl;

            for (size_t i = 0; i < globalBigInventory.entry.size(); ++i) {
                if (globalBigInventory.entry[i].m_NameUID == hash) {
                    //std::cout << "Matching File by extracted hash: " << relativePath << " with Hash: " << hash << std::endl;

                    importFilesMap[i] = fullFilePath;
                    lbox_files->data[lbox_files->row_to_entry_map[i]][4] = "EDITED";
                    found = true;
                    break;
                }
            }
        }
    }
}

lbox_files->redraw();} {selected
  }
}

Function {edt_crc32str_callback(Fl_Widget* widget, void*)} {private return_type void
} {
  code {Fl_Input* input = static_cast<Fl_Input*>(widget);
    const char* text = input->value();
    uint32_t hash = StringHashUpper32(text);
    std::stringstream ss;
    ss << std::uppercase << std::hex << std::setw(8) << std::setfill('0') << hash;
    edt_crc32hex->value(ss.str().c_str());
    lbox_files->filterData(text);} {}
}

Function {show_centered_message(Fl_Window* parent)} {private return_type void
} {
  code {// Dimensions of the custom message box
int msgBoxW = 540;
int msgBoxH = 180;

// Calculate the position to center the message box
int msgBoxX = parent->x() + (parent->w() - msgBoxW) / 2;
int msgBoxY = parent->y() + (parent->h() - msgBoxH) / 2;

// Create a new window for the message box
Fl_Window* msgBox = new Fl_Window(msgBoxX, msgBoxY, msgBoxW, msgBoxH, "About");

// Create the left group with the image
Fl_Group* leftGroup = new Fl_Group(10, 10, 100, 100);
Fl_Pixmap* pixmap = new Fl_Pixmap(logo);
Fl_Box* imgBox = new Fl_Box(10, 10, 100, 100);
imgBox->image(pixmap);
imgBox->box(FL_FLAT_BOX);
leftGroup->end();

// Create the right group with two rectangles stacked vertically
Fl_Group* rightGroup = new Fl_Group(120, 10, msgBoxW - 130, 100);
Fl_Box* titleBox = new Fl_Box(120, 10, msgBoxW - 130, 25, "Sleeping Dogs - Definitive Edition Archive Manager");
titleBox->box(FL_FLAT_BOX);
titleBox->labelsize(16);
titleBox->labelfont(FL_HELVETICA_BOLD);
titleBox->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);

Fl_Box* textBox = new Fl_Box(120, 35, msgBoxW - 130, 25, "Written by Corey Nguyen (mariokart64n)");
textBox->box(FL_FLAT_BOX);
textBox->labelsize(14);
textBox->labelfont(FL_HELVETICA);
textBox->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);

rightGroup->end();

// Draw a line across the window
Fl_Box* lineBox = new Fl_Box(10, 120, msgBoxW - 20, 1);
lineBox->box(FL_FLAT_BOX);
lineBox->color(FL_BLACK);

// Add the close button at the bottom center
Fl_Button* okButton = new Fl_Button(msgBoxW - 90, msgBoxH - 50, 80, 30, "OK");
okButton->callback([](Fl_Widget* w, void*) {
	Fl_Window* win = (Fl_Window*)w->window();
	win->hide();
});

msgBox->end();
msgBox->set_modal();
msgBox->show();} {}
}

Function {mnu_main_open_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {OPENFILENAME ofn;       // common dialog box structure
    char szFile[260];       // buffer for file name

    // Initialize OPENFILENAME
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = fl_xid(mainWindow); // get the main window handle
    ofn.lpstrFile = szFile;
    // Set lpstrFile[0] to '\\0' so that GetOpenFileName does not use the contents of szFile to initialize itself.
    ofn.lpstrFile[0] = '\\0';
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = "BIX Files\\0*.bix\\0All Files\\0*.*\\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

    // Display the Open dialog box
    if (GetOpenFileName(&ofn) == TRUE) {
        std::string bixPath = ofn.lpstrFile;
        if (loadBixFile(bixPath)) {
            importFilesMap.clear();
            lbox_files->reset_table();
            lbox_files->load_entries(globalBigInventory);
            updateLabels();
        } else {
            fl_alert("Failed to load BIX file!");
        }
    }} {}
}

Function {mnu_main_save_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {if (globalBixPath.empty() || globalBigPath.empty()) {
    fl_alert("No BIX file loaded!");
    return;
}

// Backup original files
if (!CopyFile(globalBixPath.c_str(), (globalBixPath + ".bak").c_str(), FALSE) ||
    !CopyFile(globalBigPath.c_str(), (globalBigPath + ".bak").c_str(), FALSE)) {
    fl_alert("Failed to create backup files!");
    return;
}

HANDLE hBigFile = CreateFile(globalBigPath.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if (hBigFile == INVALID_HANDLE_VALUE) {
    fl_alert("Could not open original big file!");
    return;
}

HANDLE hNewBigFile = CreateFile((globalBigPath + ".new").c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
if (hNewBigFile == INVALID_HANDLE_VALUE) {
    fl_alert("Could not create new big file!");
    CloseHandle(hBigFile);
    return;
}

try {
    uint32_t currentOffset = 0;
    QuickCompression qc; // Initialize the QuickCompression instance
    const size_t chunkSize = 4096;
    bool enableFileCompression = false; // Set this flag based on your application's requirements

    for (size_t i = 0; i < globalBigInventory.entry.size(); ++i) {
        if (importFilesMap.find(i) != importFilesMap.end()) {
            std::string importFilePath = importFilesMap[i];
            uint32_t uncompressedSize = static_cast<uint32_t>(os::getFileSize(importFilePath));
            if (uncompressedSize == -1) {
                throw std::runtime_error("Failed to get file size of " + importFilePath);
            }
            uint32_t uncompressedPadding = (chunkSize - (uncompressedSize % chunkSize)) % chunkSize;
            uint32_t totalUncompressedSize = uncompressedSize + uncompressedPadding;


            globalBigInventory.entry[i].m_CompressedSize = 0;
            globalBigInventory.entry[i].m_CompressedExtra = 0;

            if (enableFileCompression) {
                try {
                    std::vector<uint8_t> compressedData = qc.CompressToBuffer(importFilePath);
                    if (compressedData.size() < sizeof(UFG::qCompressHeader)) {
                        throw std::runtime_error("Compressed data is too small to contain a valid header.");
                    }

                    UFG::qCompressHeader header;
                    std::memcpy(&header, compressedData.data(), sizeof(UFG::qCompressHeader));

                    uint32_t compressedSize = static_cast<uint32_t>(compressedData.size());
                    uint32_t beginingPadding = (header.mDataOffset * 4) + (currentOffset % chunkSize);
                    uint32_t endingPadding = (chunkSize - ((compressedSize + beginingPadding) % chunkSize)) % chunkSize;
                    uint32_t totalCompressedSize = compressedSize + beginingPadding + endingPadding;

                    if (totalCompressedSize < totalUncompressedSize) {
                        // Write begining padding
                        if (beginingPadding > 0) {
                            std::vector<uint8_t> padding(beginingPadding, 0);
                            DWORD bytesWritten;
                            if (!WriteFile(hNewBigFile, padding.data(), beginingPadding, &bytesWritten, NULL)) {
                                throw std::runtime_error("Failed to write beginning padding to new big file.");
                            }
                        }

                        // Write compressed data to the new big file
                        DWORD bytesWritten;
                        if (!WriteFile(hNewBigFile, compressedData.data(), compressedSize, &bytesWritten, NULL)) {
                            throw std::runtime_error("Failed to write compressed data to new big file.");
                        }

                        // Write ending padding
                        if (endingPadding > 0) {
                            std::vector<uint8_t> padding(endingPadding, 0);
                            if (!WriteFile(hNewBigFile, padding.data(), endingPadding, &bytesWritten, NULL)) {
                                throw std::runtime_error("Failed to write ending padding to new big file.");
                            }
                        }

                        // Update entry details
                        globalBigInventory.entry[i].m_Offset = currentOffset;
                        globalBigInventory.entry[i].m_CompressedSize = compressedSize;
                        globalBigInventory.entry[i].m_UncompressedSize = uncompressedSize;
                        globalBigInventory.entry[i].m_LoadOffset = header.mDataOffset;
                        globalBigInventory.entry[i].m_CompressedExtra = header.mInPlaceExtraNumBytes;

                        // Update currentOffset
                        currentOffset += totalCompressedSize / 4;
                        continue;
                    }
                } catch (const std::exception& e) {
                    std::cerr << "Compression error: " << e.what() << std::endl;
                    throw;
                }
            }

            // If compression is not enabled or compression does not reduce size, write uncompressed data
            if (!importFile(hBigFile, hNewBigFile, importFilePath, globalBigInventory.entry[i], currentOffset)) {
                throw std::runtime_error("Failed to import uncompressed file.");
            }

            // Write uncompressed data padding
            DWORD bytesWritten;
            if (uncompressedPadding > 0) {
                std::vector<uint8_t> padding(uncompressedPadding, 0);
                if (!WriteFile(hNewBigFile, padding.data(), uncompressedPadding, &bytesWritten, NULL)) {
                    throw std::runtime_error("Failed to write uncompressed data padding to new big file.");
                }
            }

            currentOffset += totalUncompressedSize;
        } else {
            if (!copyOriginalData(hBigFile, hNewBigFile, globalBigInventory.entry[i], currentOffset)) {
                throw std::runtime_error("Failed to copy original data.");
            }
        }
    }

    CloseHandle(hBigFile);
    CloseHandle(hNewBigFile);

    if (!MoveFileEx((globalBigPath + ".new").c_str(), globalBigPath.c_str(), MOVEFILE_REPLACE_EXISTING)) {
        throw std::runtime_error("Could not replace original big file.");
    }

    // Create new BIX file
    bytestream newBixStream;
    newBixStream.createFile(globalBigInventory.entry.size() * sizeof(BigInventoryEntry_t));
    globalBigInventory.write(newBixStream);

    HANDLE hNewBixFile = CreateFile(globalBixPath.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hNewBixFile == INVALID_HANDLE_VALUE) {
        throw std::runtime_error("Could not create new bix file.");
    }
    DWORD bytesWritten = 0;
    if (!WriteFile(hNewBixFile, newBixStream.stream, newBixStream.size, &bytesWritten, NULL)) {
        CloseHandle(hNewBixFile);
        throw std::runtime_error("Could not write to new bix file.");
    }

    CloseHandle(hNewBixFile);
    newBixStream.close();
    importFilesMap.clear();
    lbox_files->reset_row_colors();

    fl_alert("Archive saved successfully!");
} catch (const std::exception& e) {
    CloseHandle(hBigFile);
    CloseHandle(hNewBigFile);
    fl_alert(e.what());
}} {}
}

Function {mnu_main_exit_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {if (!importFilesMap.empty()) {
        int choice = fl_choice("There are pending file operations.\\nDo you want to save changes before exiting?", "Cancel", "Save and Exit", "Exit Without Saving");
        if (choice == 0) {
            return; 
        } else if (choice == 1) {
            mnu_main_save_callback(nullptr, nullptr);
        } 
    }
    exit(0);} {}
}

Function {mnu_main_exp_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {exportSelectedFiles();} {}
}

Function {mnu_main_imp_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {importFileToSelectedRow();} {}
}

Function {mnu_main_exp_all_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {exportAllFiles();} {}
}

Function {mnu_main_imp_all_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {importAllFiles();} {}
}

Function {mnu_main_add_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {lbox_files->addEntry();} {}
}

Function {mnu_main_del_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {lbox_files->deleteSelectedEntries();} {}
}

Function {mnu_main_null_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {lbox_files->nullifySelectedEntries();} {}
}

Function {mnu_main_about_callback(Fl_Widget*, void*)} {private return_type void
} {
  code {//fl_message("Written by Corey Nguyen (mariokart64n)");
Fl_Window* mainWindow = Fl::first_window();  // Assuming mainWindow is the first window
if (mainWindow) {
	show_centered_message(mainWindow);
}} {}
}

Function {handle_exit_event(int event)} {private return_type int
} {
  code {if (event == FL_SHORTCUT && Fl::event_key() == FL_Escape) {
        return 1;
    }
    if (event == FL_CLOSE) {
        if (!importFilesMap.empty()) {
            int choice = fl_choice("There are pending file operations.\\nDo you want to save changes before exiting?", "Cancel", "Save and Exit", "Exit Without Saving");
            if (choice == 0) {
                return 1; 
            } else if (choice == 1) {
                mnu_main_save_callback(nullptr, nullptr);
            }
        }
        return 1; 
    }
    return 0;} {}
}

Function {add_multi_label(Fl_Menu_Item* &o, Fl_Image* image)} {private return_type void
} {
  code {const char* l = o->label();
o->image(image);
Fl_Multi_Label *ml = new Fl_Multi_Label;
ml->typea  = _FL_IMAGE_LABEL;
ml->labela = (const char*)image;
ml->typeb  = FL_NORMAL_LABEL;
ml->labelb = (char*)l;
ml->label(o);
o->label(_FL_MULTI_LABEL , (const char *)ml);} {}
}

class MyTable {open : {public Fl_Table_Row}
} {
  decl {std::vector<std::vector<std::string>> data;} {public local
  }
  decl {std::vector<std::vector<std::string>> original_data;} {public local
  }
  decl {int secondary_selection[4];} {public local
  }
  decl {std::vector<bool> displayStatus;} {public local
  }
  decl {bool useStatusColors;} {public local
  }
  decl {std::vector<int> sort_direction;} {public local
  }
  decl {int sorting_column;} {public local
  }
  decl {std::vector<int> indices;} {public local
  }
  decl {bool resizing = false;} {public local
  }
  decl {int resizing_col;} {public local
  }
  decl {int resizing_start_x;} {public local
  }
  decl {int resizing_start_width;} {public local
  }
  decl {int original_x;} {public local
  }
  decl {int original_y;} {public local
  }
  decl {int original_w;} {public local
  }
  decl {int original_h;} {public local
  }
  decl {bool altKeyPressed;} {private local
  }
  decl {std::vector<int> row_to_entry_map;} {
    comment {Mapping from displayed rows to globalBigInventory entries} public local
  }
  decl {std::string headers[5] = {"Hash", "Filename", "Offset", "Size", "Status"};} {public local
  }
  decl {Fl_Input* search_input;} {
    comment {// Reference to the search input widget} public local
  }
  Function {MyTable(int X, int Y, int W, int H, const char* L = "") : Fl_Table_Row(X, Y, W, H, L)} {return_type MyTable
  } {
    code {end();
rows(18);
cols(5);
col_header(1);
row_header(1);
col_resize(1);
row_resize(1);
col_width(0, 100);
col_width(1, 300);
col_width(2, 100);
col_width(3, 100);
col_width(4, 95);
row_height_all(20);
table_box(FL_NO_BOX);
when(FL_WHEN_RELEASE);
end();
sort_direction = std::vector<int>(cols(), 0);
sorting_column = -1;

// Ensure row_to_entry_map is initialized
updateRowToEntryMap();
ensureMinimumRows();} {}
  }
  Function {draw_cell(TableContext context, int R, int C, int X, int Y, int W, int H) override} {
    comment {remove 'override' from the .cxx and leave in .h} open protected return_type void
  } {
    code {static char s[64];
switch (context) {
  case CONTEXT_STARTPAGE: {
      fl_font(FL_HELVETICA, 12);
      return;
      }

  case CONTEXT_COL_HEADER: {
      DrawHeader(C, X, Y, W, H); // Call DrawHeader function
//            fl_push_clip(X, Y, W, H);
//            {
//                fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, col_header_color());
//                fl_color(FL_BLACK);
//                fl_font(FL_HELVETICA_BOLD, 14); // Header text bold
//                const char* col_name = headers[C].c_str();
//                fl_draw(col_name, X, Y, W, H, FL_ALIGN_CENTER);
//                if (C == sorting_column) {
//                    int mid_x = X + W - 10;
//                    int mid_y = Y + H / 2;
//                    if (sort_direction[C] == 1) {
//                        fl_polygon(mid_x, mid_y + 5, mid_x - 5, mid_y - 5, mid_x + 5, mid_y - 5);
//                    } else {
//                        fl_polygon(mid_x, mid_y - 5, mid_x - 5, mid_y + 5, mid_x + 5, mid_y + 5);
//                    }
//                }
//            }
//            fl_pop_clip();
      return;
      }

  case CONTEXT_ROW_HEADER: {
      snprintf(s, sizeof(s), "%03d:", R);
      fl_push_clip(X, Y, W, H); {
          fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, row_header_color());
          fl_color(FL_BLACK);
          fl_draw(s, X, Y, W, H, FL_ALIGN_CENTER);
          }
      fl_pop_clip();
      return;
      }

  case CONTEXT_CELL: {

      // Default Light Colours
      int fgcol = FL_BLACK;
      int bgcol = FL_WHITE;

      int noname = fl_rgb_color(180, 180, 220); // light grey
      int edited = fl_rgb_color(243, 234, 85); // Red for edited entries
      int compressed = fl_rgb_color(228, 250, 228); // light pastel green
      //int compressed = fl_rgb_color(245, 245, 220);  // beige (light cream)
      //int compressed = fl_rgb_color(176, 224, 230);  // powder blue

      int uncompressed = fl_rgb_color(212, 240, 227); // light green
      //int uncompressed = fl_rgb_color(255, 250, 205);  // lemon chiffon (light cream)
      //int uncompressed = fl_rgb_color(173, 216, 230);  // light blue
      //int uncompressed = fl_rgb_color(152, 251, 152);  // light green

      int nulled = fl_rgb_color(253, 221, 215); // pale tomato
      //int nulled = fl_rgb_color(240, 230, 140);  // khaki (light cream)
      //int nulled = fl_rgb_color(175, 238, 238);  // pale turquoise
      //int nulled = fl_rgb_color(255, 160, 122);  // pale tomato

      int cellhighlight = fl_rgb_color(0, 0, 139); // Set the color to dark blue
      int cellborders = FL_LIGHT2; // Set the color to dark blue

      if (USE_DARK_MODE) {
          fgcol = fl_rgb_color(200, 200, 200); // Light gray for foreground text in dark theme
          bgcol = fl_rgb_color(50, 50, 50);    // Dark gray for background
          noname = fl_rgb_color(70, 70, 90);   // Dark desaturated blue for empty rows

          edited = fl_rgb_color(120, 110, 40); // Darker desaturated yellow for imported files

          compressed = fl_rgb_color(70, 90, 70); // Dark desaturated green for QCMP files

          uncompressed = fl_rgb_color(60, 90, 80); // Dark desaturated green for RAW files

          nulled = fl_rgb_color(110, 60, 60); // Dark desaturated red for other files

          cellhighlight = fl_rgb_color(150, 150, 150);
          cellborders = fl_rgb_color(70, 70, 70); // Dark gray for cell borders
          }

      fl_push_clip(X, Y, W, H); {


          // Determine background color based on status (from the fifth cell)
          if (R < (signed int) data.size()) {
              const auto & row = data[R];
              int entryIndex = lbox_files -> row_to_entry_map[R];
              if (row[1] == "" && row[4] == "") {
                  //bgcol = noname;
                  }
              else if (row[1] == "") {
                  bgcol = noname;
                  if (importFilesMap.find(entryIndex) != importFilesMap.end()) {
                      bgcol = edited;
                      lbox_files -> data[entryIndex][4] = "EDITED";
                      }
                  }
              else {

                  if (importFilesMap.find(entryIndex) != importFilesMap.end()) {
                      bgcol = edited;
                      lbox_files -> data[entryIndex][4] = "EDITED";
                      }
                  else if (row[4] == "RAW") {
                      bgcol = uncompressed;
                      }
                  else if (row[4] == "QCMP") {
                      bgcol = compressed;
                      }
                  else {

                      bgcol = nulled;
                      }
                  }
              }

          if (row_selected(R)) {
              fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, bgcol);
              fl_color(cellhighlight); // Set the color to dark blue

              const int paddingX = 5;
              const int paddingY = 2;
              int cellWidth = W - (2 * paddingX);
              int cellHeight = H - (2 * paddingY);

              int line_spacing = 10;
              int line_length = sqrt(pow(cellWidth, 2) + pow(cellHeight, 2));
              fl_line_style(FL_SOLID, 1); // Increase the width parameter to make the pattern thicker
              for (int i = 0; i < cellWidth + cellHeight; i += line_spacing) {
                  fl_line(X + paddingX + cellWidth - i, Y + paddingY, X + paddingX + cellWidth - i + line_length, Y + paddingY + line_length);
                  }
              fl_line_style(0); // Reset line style to default after drawing the pattern

              fl_color(fgcol); // Reset color to original foreground color for text
              }
          else {
              // Normal cell
              fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, bgcol);
              fl_color(fgcol);
              }

          // Draw text
          const char * cell_text = "";
          if (R < (signed int) data.size()) {
              const auto & row = data[R];
              snprintf(s, sizeof(s), "%s", row[C].c_str());
              cell_text = s;
              }
          fl_font(FL_HELVETICA, 12); // Regular text for cells
          fl_draw(cell_text, X + 5, Y, W - 10, H, FL_ALIGN_LEFT);

          fl_color(cellborders);
          fl_rect(X, Y, W, H);
          }
      fl_pop_clip();
      return;
      }


  default: return;
  }} {}
  }
  Function {handle(int event) override} {
    comment {remove 'override' from the .cxx and leave in .h} open protected return_type int
  } {
    code {switch (event) {
    case FL_FOCUS:
    case FL_UNFOCUS:
        // Force redraw on focus change
        redraw();
        break;
    case FL_PUSH:
        // Set focus when the table is clicked


        if (Fl::event_button() == FL_LEFT_MOUSE && Fl::event_clicks()) {
            if (callback_context() == CONTEXT_CELL) {
                showEditPopup(callback_row());
                Fl::event_clicks(0);
                return 1;
            }
            }

        take_focus();
        if (Fl::event_button() == FL_LEFT_MOUSE) {
            Fl::add_timeout(0.001, [](void* data) { static_cast<MyTable*>(data)->handleDelayedTask(); }, this);
            redraw();
        }
      else if (Fl::event_button() == FL_RIGHT_MOUSE) {
          int R = callback_row(), C = callback_col();
          if (!row_selected(R)) {
              select_row(R, 1);
          }
          create_context_menu();
          return 1;
      }

      break;
    case FL_KEYDOWN:
        if (Fl::event_key() == 'f' && Fl::event_state() & FL_CTRL) {
            // no longer needed
        } else if (Fl::event_key() == 'c' && Fl::event_state() & FL_CTRL) {
            if (callback_row() >= 0 && callback_col() >= 0) {
                std::string s = data[callback_row()][callback_col()];
                Fl::copy(s.c_str(), s.length(), 1);
            }
        } else if (Fl::event_key() == FL_F + 11) {
            Fl_Window* win = this->window();
            if (win) {
                if (!win->fullscreen_active()) {
                    original_x = win->x();
                    original_y = win->y();
                    original_w = win->w();
                    original_h = win->h();
                    win->fullscreen();
                } else {
                    win->fullscreen_off(original_x, original_y, original_w, original_h);
                }
            }
        } else if (Fl::event_key() == FL_Escape) {
            this->window()->hide();
        }
        break;
    case FL_DRAG:
        if (resizing) {
            int delta = Fl::event_x() - resizing_start_x;
            int new_width = resizing_start_width + delta;
            if (new_width > 5) {
                col_width(resizing_col, new_width);
                table->init_sizes();
                redraw();
            }
            return 1;
        }
        redraw();
        break;
    case FL_RELEASE:
        if (resizing) {
            resizing = false;
            return 1;
        }
        break;
    default:
        break;
}

if (Fl::event_clicks() && Fl::event_button() == FL_LEFT_MOUSE) {
    if (callback_context() == CONTEXT_CELL) {
        // not used
        Fl::event_clicks(0);
        return 1;
    }
}

return Fl_Table_Row::handle(event);} {}
  }
  Function {nullifySelectedEntries()} {return_type void
  } {
    code {for (int row = 0; row < rows(); ++row) {
    if (row_selected(row)) {
        int entryIndex = row_to_entry_map[row];

        // Ensure the index is within bounds
        if (entryIndex >= 0 && entryIndex < static_cast<int>(globalBigInventory.entry.size())) {
            memset(&globalBigInventory.entry[entryIndex].m_Offset, 0, sizeof(BigInventoryEntry_t) - sizeof(uint32_t));

            // Update both data and original_data
            data[row][2] = "0";
            data[row][3] = "0";
            data[row][4] = "NULL";

            for (auto& row_data : original_data) {
                if (row_data[0] == data[row][0]) {
                    row_data[2] = "0";
                    row_data[3] = "0";
                    row_data[4] = "NULL";
                    break;
                    }
                }
            }
        }
    }
redraw();} {}
  }
  Function {deleteSelectedEntries()} {return_type void
  } {
    code {std::vector<int> selectedRows;
for (int row = 0; row < rows(); ++row) {
    if (row_selected(row)) {
        selectedRows.push_back(row);
        }
    }

// Sort in descending order to avoid reindexing issues
std::sort(selectedRows.rbegin(), selectedRows.rend());

for (int row : selectedRows) {
    int entryIndex = row_to_entry_map[row];
    if (entryIndex != -1) { // Ignore placeholders
        globalBigInventory.entry.erase(globalBigInventory.entry.begin() + entryIndex);
        globalBigInventory.m_EntryCount--;

        // Adjust row_to_entry_map for entries after the deleted one
        for (int& mapIndex : row_to_entry_map) {
            if (mapIndex > entryIndex) {
                --mapIndex;
                }
            }

        // Remove the entry from original_data
        original_data.erase(original_data.begin() + entryIndex);
        }
    // Remove the row from data
    data.erase(data.begin() + row);
    row_to_entry_map.erase(row_to_entry_map.begin() + row);
    }

updateRowToEntryMap();
ensureMinimumRows();
redraw();} {}
  }
  Function {addEntry()} {return_type void
  } {
    code {// Prompt the user to select a file to import
std::string importFilePath = os::getOpenFileName("All Files (*.*)\\0*.*\\0", GetActiveWindow());
if (importFilePath.empty()) {
    return;
    }

// Ensure globalBigInventory is initialized
if (globalBigInventory.entry.empty()) {
    globalBigInventory.entry = std::vector<BigInventoryEntry_t>();
    globalBigInventory.m_EntryCount = 0;
    }

// Create a new entry
BigInventoryEntry_t newEntry;
memset(&newEntry, 0, sizeof(BigInventoryEntry_t));
newEntry.m_NameUID = StringHashUpper32(importFilePath.c_str());

// Get the file size using Windows API
HANDLE hFile = CreateFile(importFilePath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if (hFile != INVALID_HANDLE_VALUE) {
    LARGE_INTEGER fileSize;
    if (GetFileSizeEx(hFile, &fileSize)) {
        newEntry.m_UncompressedSize = static_cast<uint32_t>(fileSize.QuadPart);
        }
    CloseHandle(hFile);
    }
else {
    // Handle file open error
    return;
    }

// Add the new entry to the global inventory
globalBigInventory.entry.push_back(newEntry);
globalBigInventory.m_EntryCount++;

// Create a new row for the table
std::vector<std::string> newRow = { "0x" + to_hex_string(newEntry.m_NameUID), importFilePath, std::to_string(newEntry.m_Offset), std::to_string(newEntry.m_UncompressedSize), "RAW" };

// Insert the new row before placeholders
int insertPos = data.size();
for (int i = 0; i < data.size(); ++i) {
    if (row_to_entry_map[i] == -1) {
        insertPos = i;
        break;
        }
    }
data.insert(data.begin() + insertPos, newRow);
original_data.insert(original_data.begin() + insertPos, newRow);
updateRowToEntryMap();

// Add the new file path to the hash map
uint32_t hash = StringHashUpper32(importFilePath.c_str());
fileHashMap[hash] = importFilePath;

// Update the table row count and redraw
rows(static_cast<int>(data.size()));
ensureMinimumRows(); // Ensure table has minimum rows
redraw();

// Scroll to the newly added entry
if (insertPos >= 0) {
    row_position(insertPos); // Scroll to the new row
    }} {}
  }
  Function {reset_row_colors()} {return_type void
  } {
    code {for (int R = 0; R < rows(); ++R) {
            if (importFilesMap.find(R) != importFilesMap.end()) {
                importFilesMap.erase(R);
            }
        }
        redraw();} {}
  }
  Function {reset_table()} {return_type void
  } {
    code {//rows(0); // Auto Resize Rows
importFilesMap.clear();
redraw();} {}
  }
  Function {load_entries(const BigInventory_t &inventory)} {return_type void
  } {
    code {rows(inventory.entry.size());
data.clear();
original_data.clear();
for (const auto & entry: inventory.entry) {
    std::vector < std::string > row;
    row.push_back("0x" + to_hex_string(entry.m_NameUID));
    row.push_back(getFilePathFromHash(entry.m_NameUID));
    row.push_back(std::to_string(entry.m_Offset));
    row.push_back(std::to_string(entry.m_UncompressedSize));
    if (entry.m_CompressedSize == 0 && entry.m_UncompressedSize > 0) {
        row.push_back("RAW");
        }
    else if (entry.m_CompressedSize > 0) {
        row.push_back("QCMP");
        }
    else {
        row.push_back("NULL");
        }
    data.push_back(row);
    original_data.push_back(row);
    }
updateRowToEntryMap();
ensureMinimumRows();
redraw();} {}
  }
  Function {DrawHeader(int C, int X, int Y, int W, int H)} {return_type void
  } {
    code {fl_push_clip(X, Y, W, H);
{
	fl_draw_box(FL_THIN_UP_BOX, X, Y, W, H, col_header_color());
	fl_color(FL_BLACK);
	fl_font(FL_HELVETICA_BOLD, 14);
	const char* s = headers[C].c_str();
	fl_draw(s, X, Y, W, H, FL_ALIGN_CENTER);
	if (C < (signed int)sort_direction.size() && sort_direction[C] != 0) {
		int mid_x = X + W - 10;
		int mid_y = Y + H / 2;
		if (sort_direction[C] == 1) {
			fl_polygon(mid_x, mid_y + 5, mid_x - 5, mid_y - 5, mid_x + 5, mid_y - 5);
		} else {
			fl_polygon(mid_x, mid_y - 5, mid_x - 5, mid_y + 5, mid_x + 5, mid_y + 5);
		}
	}
}
fl_pop_clip();} {}
  }
  Function {sort_column(int col)} {return_type void
  } {
    code {if (sorting_column != col) {
        sort_direction = std::vector<int>(cols(), 0);
        sorting_column = col;
    }
    switch (sort_direction[col]) {
        case 0: {
            data = original_data;
            sort_direction[col] = 1;
            break;
        }
        case 1: {
            std::sort(data.begin(), data.end(), [&](const std::vector<std::string>& a, const std::vector<std::string>& b) {
                return a[col] > b[col];
            });
            sort_direction[col] = 2;
            break;
        }
        case 2: {
            std::sort(data.begin(), data.end(), [&](const std::vector<std::string>& a, const std::vector<std::string>& b) {
                return a[col] < b[col];
            });
            sort_direction[col] = 0;
            break;
        }
    }
    updateRowToEntryMap();
    redraw();} {}
  }
  Function {sort_by_column(int column)} {return_type void
  } {
    code {if (column < 0 || column >= (signed int) sort_direction.size()) {
    return;
}
if (sort_direction[column] == 0) {
    sort_direction[column] = -1;
} else if (sort_direction[column] == -1) {
    sort_direction[column] = 1;
} else {
    sort_direction[column] = 0;
    data = original_data;
    redraw();
    return;
}
if (sort_direction[column] != 0) {
    std::sort(data.begin(), data.end(), [column, this](const std::vector < std::string > & a,
        const std::vector < std::string > & b) {
        return (sort_direction[column] * a[column].compare(b[column])) < 0;
    });
}
updateRowToEntryMap();
redraw();} {}
  }
  Function {filterData(const std::string& filter_text)} {return_type void
  } {
    code {std::vector<std::vector<std::string>> filtered_data;
std::string lower_filter_text = to_uppercase(filter_text);

std::vector<std::string> filter_words;
std::istringstream iss(lower_filter_text);
std::string word;
while (iss >> word) {
    filter_words.push_back(word);
    }

for (const auto& row : original_data) {
    std::string lower_filename = to_uppercase(row[1]);
    bool match = true;

    for (const auto& filter_word : filter_words) {
        if (lower_filename.find(filter_word) == std::string::npos) {
            match = false;
            break;
            }
        }

    if (match) {
        filtered_data.push_back(row);
        }
    }

data = filtered_data;
updateRowToEntryMap();
rows(static_cast<int>(data.size()));
ensureMinimumRows();
redraw();} {}
  }
  Function {handle_click_on_header(int col)} {return_type void
  } {
    code {sort_column(col);} {}
  }
  Function {resize_to_fit(int col)} {return_type void
  } {
    code {int max_width = 50;
fl_font(FL_HELVETICA, 16);
for (int r = 0; r < (int)data.size(); ++r) {
	int w = 0, h = 0;
	fl_measure(data[r][col].c_str(), w, h, 0);
	if (w > max_width) {
		max_width = w;
	}
}
max_width += 10;
col_width(col, max_width);
redraw();} {}
  }
  Function {get_col_under_mouse(int mouse_x)} {return_type int
  } {
    code {int col_right_edge = row_header_width();
        for (int col = 0; col < cols(); ++col) {
            col_right_edge += col_width(col);
            if (std::abs(col_right_edge - mouse_x) < 5) {
                return col;
            }
        }
        return -1;} {}
  }
  Function {get_col_under_mouse_for_sort(int mouse_x)} {return_type int
  } {
    code {int col_left_edge = row_header_width();
        int col_right_edge;
        for (int col = 0; col < cols(); ++col) {
            col_right_edge = col_left_edge + col_width(col);
            if (mouse_x >= col_left_edge && mouse_x < col_right_edge) {
                return col;
            }
            col_left_edge = col_right_edge;
        }
        return -1;} {}
  }
  Function {create_context_menu()} {return_type void
  } {
    code {static Fl_Menu_Item rclick_menu[] = {
    menu_mnu_main[6], // Export Selection
    menu_mnu_main[7], // Export All to Folder
    menu_mnu_main[8], // Import Selection
    menu_mnu_main[9], // Import From Folder
    menu_mnu_main[10], // Add Entry
    menu_mnu_main[11], // Delete Selected Entries
    menu_mnu_main[12], // Nullify Selected Entries
    {0} // End of menu
};

int X = Fl::event_x();
int Y = Fl::event_y();
Fl_Menu_Button* mb = new Fl_Menu_Button(X, Y, 0, 0);
mb->type(Fl_Menu_Button::POPUP3);

// Set modern styles
mb->color(FL_WHITE);
mb->textcolor(FL_BLACK);
mb->textfont(FL_HELVETICA);
mb->textsize(14);
mb->box(FL_FLAT_BOX);
mb->menu(rclick_menu);

const Fl_Menu_Item* m = mb->menu()->popup(X, Y);
if (m) m->do_callback(mb, m->user_data());

delete mb;} {}
  }
  Function {col_right_edge(int col)} {return_type int
  } {
    code {int right_edge = x() + row_header_width();
        for (int c = 0; c <= col; ++c) {
            right_edge += col_width(c);
        }
        return right_edge;} {}
  }
  Function {setData(const std::vector<std::vector<std::string>>& newData)} {return_type void
  } {
    code {data = newData;
original_data = newData;
//filterData();
redraw();
rows((int)data.size());
ensureMinimumRows();
if (!data.empty()) {
    cols((int)data[0].size());
    sort_direction = std::vector<int>(cols(), 0);
    }} {}
  }
  Function {updateRowToEntryMap()} {private return_type void
  } {
    code {row_to_entry_map.clear();
for (const auto& row : data) {
    auto it = std::find(original_data.begin(), original_data.end(), row);
    if (it != original_data.end()) {
        row_to_entry_map.push_back(std::distance(original_data.begin(), it));
        }
    else {
        row_to_entry_map.push_back(-1); // Mark this as a placeholder
        }
    }} {}
  }
  Function {find_and_select(const std::string& find_str, bool whole_word_only)} {private return_type bool
  } {
    code {int start_row = 0;
int start_col = 0;
for (int r = 0; r < (signed int)data.size(); ++r) {
	for (int c = 0; c < (signed int)data[r].size(); ++c) {
		if (is_selected(r, c)) {
			start_row = r;
			start_col = c;
		}
	}
}
bool wraparound = false;
while (true) {
	if (start_col >= (signed int)data[start_row].size() - 1) {
		start_row = (start_row + 1) % data.size();
		start_col = 0;
	} else {
		start_col++;
	}
	for (int row = start_row; row < (signed int)data.size(); ++row) {
		for (int col = (row == start_row ? start_col : 0); col < (signed int)data[row].size(); ++col) {
			if (whole_word_only) {
				std::string uppercase_cell = to_uppercase(data[row][col]);
				std::string uppercase_find_str = to_uppercase(find_str);

				if (uppercase_cell == uppercase_find_str) {
					select_all_rows(0);
					select_row(row);
					vscrollbar->value(row * row_height(row));
					redraw();
					if (wraparound) {
						start_row = row;
						start_col = col;
						wraparound = false;
						break;
					} else {
						return true;
					}
				}
			} else {
				if (data[row][col].find(find_str) != std::string::npos) {
					select_all_rows(0);
					select_row(row);
					vscrollbar->value(row * row_height(row));
					redraw();
					if (wraparound) {
						start_row = row;
						start_col = col;
						wraparound = false;
						break;
					} else {
						return true;
					}
				}
			}
		}
	}
	if (!wraparound) {
		wraparound = true;
		start_row = 0;
		start_col = -1;
	} else {
		break;
	}
}
fl_alert("Nothing was found");
return false;} {}
  }
  Function {handleDelayedTask()} {private return_type void
  } {
    code {int col_for_resize = get_col_under_mouse(Fl::event_x());
int col_for_sort = get_col_under_mouse_for_sort(Fl::event_x());
int context = callback_context();
int mouse_x = Fl::event_x();
if (context == 8 || context == 32) {
		if (col_for_resize > -1) {
			if (Fl::event_clicks()) {
				if (std::abs(mouse_x - col_right_edge(col_for_resize)) < 5) {
					resize_to_fit(col_for_resize);
					Fl::event_clicks(0);
					}
				}
			}
	else {
		if (col_for_sort > -1 && !Fl::event_clicks()) {
			sort_by_column(col_for_sort);
			}
		}
	}} {}
  }
  Function {performDelayedTask()} {private return_type void
  } {
    code {int col_for_resize = get_col_under_mouse(Fl::event_x());
        int col_for_sort = get_col_under_mouse_for_sort(Fl::event_x());
        int context = callback_context();
        int mouse_x = Fl::event_x();
        if (context == 8 || context == 32) {
            if (col_for_resize > -1) { 
                if (Fl::event_clicks()) {
                    if (std::abs(mouse_x - col_right_edge(col_for_resize)) < 5) {
                        resize_to_fit(col_for_resize);
                        Fl::event_clicks(0);
                    }
                }
            } else {
                if (col_for_sort > -1 && !Fl::event_clicks()) {
                    sort_by_column(col_for_sort);
                }
            }
        }} {}
  }
  Function {ensureMinimumRows()} {
    comment {Set minimum rows to extend to the bottom of the table} private return_type void
  } {
    code {int minRows = 18; // Set minimum rows to extend to the bottom of the table
// Remove existing placeholders
for (auto it = data.begin(); it != data.end();) {
    if (std::all_of(it->begin(), it->end(), [](const std::string& s) { return s.empty(); })) {
        it = data.erase(it);
        original_data.erase(original_data.begin() + std::distance(data.begin(), it));
        row_to_entry_map.erase(row_to_entry_map.begin() + std::distance(data.begin(), it));
        }
    else {
        ++it;
        }
    }
// Add placeholders to ensure minimum rows
while (static_cast<int>(data.size()) < minRows) {
    std::vector<std::string> emptyRow(cols(), "");
    data.push_back(emptyRow);
    original_data.push_back(emptyRow);
    row_to_entry_map.push_back(-1); // Mark this as a placeholder
    }
rows(static_cast<int>(data.size()));} {}
  }
  Function {showEditPopup(int row)} {private return_type void
  } {
    code {if (row < 0 || row >= (int)data.size() || row_to_entry_map[row] == -1) {
    return; // Invalid row or placeholder
}

int entryIndex = row_to_entry_map[row];
std::string currentFilename = data[row][1];
std::string currentHash = data[row][0];

Fl_Window* popup = new Fl_Window(400, 150, "Edit Entry");

// Center the popup window relative to the main window
int popupX = mainWindow->x() + (mainWindow->w() - popup->w()) / 2;
int popupY = mainWindow->y() + (mainWindow->h() - popup->h()) / 2;
popup->position(popupX, popupY);

Fl_Input* inputFilename = new Fl_Input(120, 20, 260, 30, "Filename:");
inputFilename->value(currentFilename.c_str());

Fl_Input* inputHash = new Fl_Input(120, 60, 260, 30, "Hash:");
inputHash->value(currentHash.c_str());

struct CallbackData {
    MyTable* table;
    int row;
    int entryIndex;
    Fl_Input* inputFilename;
    Fl_Input* inputHash;
    Fl_Window* popup;
};

CallbackData* callbackData = new CallbackData{ this, row, entryIndex, inputFilename, inputHash, popup };

inputFilename->callback([](Fl_Widget*, void* data) {
    auto* cbData = static_cast<CallbackData*>(data);
    std::string newFilename = cbData->inputFilename->value();
    uint32_t newHashValue = StringHashUpper32(newFilename.c_str());
    cbData->inputHash->value(("0x" + to_hex_string(newHashValue)).c_str());
}, callbackData);

inputHash->callback([](Fl_Widget*, void* data) {
    auto* cbData = static_cast<CallbackData*>(data);
    std::string newHashStr = cbData->inputHash->value();
    try {
        uint32_t newHashValue = std::stoul(newHashStr, nullptr, 16);
        std::string newFilename = getFilePathFromHash(newHashValue);
        cbData->inputFilename->value(newFilename.c_str());
    } catch (const std::invalid_argument& e) {
        cbData->inputFilename->value("Invalid Hash");
    }
}, callbackData);

Fl_Button* btnOk = new Fl_Button(120, 100, 80, 30, "OK");
btnOk->callback([](Fl_Widget*, void* data) {
    CallbackData* cbData = static_cast<CallbackData*>(data);
    std::string newFilename = cbData->inputFilename->value();
    std::string newHashStr = cbData->inputHash->value();

    uint32_t newHashValue = StringHashUpper32(newFilename.c_str());

    // Update the table data
    cbData->table->data[cbData->row][1] = newFilename;
    cbData->table->data[cbData->row][0] = newHashStr;

    // Update the original data
    if (cbData->entryIndex != -1) {
        cbData->table->original_data[cbData->entryIndex][1] = newFilename;
        cbData->table->original_data[cbData->entryIndex][0] = newHashStr;
    }

    // Update the hash map if necessary
    fileHashMap[newHashValue] = newFilename;

    // Update the entry in global inventory
    globalBigInventory.entry[cbData->entryIndex].m_NameUID = newHashValue;

    cbData->table->updateRowToEntryMap();
    cbData->table->redraw();
    cbData->popup->hide();
    delete cbData;
}, callbackData);

Fl_Button* btnCancel = new Fl_Button(210, 100, 80, 30, "Cancel");
btnCancel->callback([](Fl_Widget*, void* data) {
    CallbackData* cbData = static_cast<CallbackData*>(data);
    cbData->popup->hide();
    delete cbData;
}, callbackData);

popup->end();
popup->set_modal(); // Set the popup as modal
popup->show();} {}
  }
}

Function {dogpack()} {} {
  Fl_Window mainWindow {
    label {Sleeping Dogs: Definitive Edition Archive Manager} open
    xywh {3054 300 778 487} type Double resizable
    code0 {o->icon((char*)LoadIcon(fl_display, MAKEINTRESOURCE(101)));}
    code1 {//o->copy_label(appver); // insert date to title bar}
    code2 {o->show();}
    code3 {Fl::add_handler(handle_exit_event);} visible
  } {
    Fl_Menu_Bar mnu_main {open
      xywh {0 0 778 20} box FLAT_BOX
    } {
      Submenu mnu_main_file {
        label {&File} open
        xywh {0 0 62 20}
      } {
        MenuItem mnu_main_open {
          label {&Open Archive}
          callback mnu_main_open_callback
          xywh {5 5 30 20} shortcut 0x4006f
          code0 {add_multi_label(o, image_mnu_file_open());}
        }
        MenuItem mnu_main_save {
          label {&Save Archive}
          callback mnu_main_save_callback
          xywh {20 20 30 20} shortcut 0x40073 divider
          code0 {add_multi_label(o, image_mnu_file_repack());}
        }
        MenuItem mnu_main_exit {
          label {&Exit}
          callback mnu_main_exit_callback
          xywh {15 15 30 20} shortcut 0xff1b
          code0 {add_multi_label(o, image_mnu_file_exit2());}
        }
      }
      Submenu mnu_main_tools {
        label {&Tools} open
        xywh {10 10 62 20}
      } {
        MenuItem mnu_main_exp {
          label {&Export Selection}
          callback mnu_main_exp_callback
          xywh {15 15 30 20}
          code0 {add_multi_label(o, image_mnu_tool_expfile());}
        }
        MenuItem mnu_main_exp_all {
          label {Export All to Folder}
          callback mnu_main_exp_all_callback
          xywh {25 25 30 20} divider
          code0 {add_multi_label(o, image_mnu_tool_expall());}
        }
        MenuItem mnu_main_imp {
          label {&Replace Selection}
          callback mnu_main_imp_callback
          xywh {25 25 30 20}
          code0 {add_multi_label(o, image_mnu_tool_impfile());}
        }
        MenuItem mnu_main_imp_all {
          label {Replace From Folder}
          callback mnu_main_imp_all_callback
          xywh {35 35 30 20} divider
          code0 {add_multi_label(o, image_mnu_tool_impfolder());}
        }
        MenuItem mnu_main_add {
          label {&Import New File}
          callback mnu_main_add_callback
          xywh {25 25 30 20}
          code0 {add_multi_label(o, image_mnu_tool_replace());}
        }
        MenuItem mnu_main_del {
          label {&Delete File Selection}
          callback mnu_main_del_callback
          xywh {35 35 30 20}
          code0 {add_multi_label(o, image_mnu_tool_delete());}
        }
        MenuItem mnu_main_null {
          label {&Null File}
          callback mnu_main_null_callback
          xywh {40 40 30 20}
          code0 {add_multi_label(o, image_mnu_tool_disable());}
        }
      }
      Submenu mnu_main_help {
        label {&Help} open
        xywh {20 20 62 20}
      } {
        MenuItem mnu_main_about {
          label {&About}
          callback mnu_main_about_callback
          xywh {25 25 30 20}
          code0 {add_multi_label(o, image_mnu_about());}
        }
      }
    }
    Fl_Group grp_main {open
      xywh {0 20 780 444} box ENGRAVED_BOX resizable
    } {
      Fl_Group grp_crc32 {open
        xywh {10 25 760 35}
      } {
        Fl_Input edt_crc32str {
          callback edt_crc32str_callback
          xywh {14 29 609 21} when 1
        }
        Fl_Output edt_crc32hex {
          xywh {635 29 133 21}
        }
      }
      Fl_Table lbox_files {open
        xywh {10 60 760 395} box NO_BOX
        code0 {Fl_Group::current()->resizable(lbox_files);}
        class MyTable
      } {}
    }
    Fl_Group grp_statusbar {
      xywh {0 465 783 26} box EMBOSSED_BOX
    } {
      Fl_Group stb_left {
        xywh {0 465 160 25} box EMBOSSED_BOX
      } {
        Fl_Box stb_llabel {
          label label
          xywh {1 466 158 20}
        }
      }
      Fl_Group stb_mid {open
        xywh {162 465 459 25} box EMBOSSED_BOX
      } {}
      Fl_Group stb_right {open
        xywh {622 465 161 25} box EMBOSSED_BOX
      } {
        Fl_Box stb_rlabel {
          label label
          xywh {622 466 158 20}
        }
      }
    }
  }
}
